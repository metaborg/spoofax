package org.metaborg.core.build;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.metaborg.core.MetaborgRuntimeException;
import org.metaborg.core.config.IGenerateConfig;
import org.metaborg.core.config.ILanguageImplConfig;
import org.metaborg.core.language.ILanguageImpl;
import org.metaborg.util.collection.BiLinkedHashMultimap;
import org.metaborg.util.collection.BiSetMultimap;
import org.metaborg.util.collection.Sets;
import org.metaborg.util.iterators.Iterables2;

/**
 * Language build order calculation.
 */
public class BuildOrder {
    private final Iterable<ILanguageImpl> languages;
    private final List<ILanguageImpl> buildOrder;


    /**
     * Creates a build order for given languages, using their dependencies.
     * 
     * @param languages
     *            Languages to create a build order for.
     * @throws MetaborgRuntimeException
     *             When there is a cyclic dependency between languages.
     */
    public BuildOrder(Iterable<ILanguageImpl> languages) throws MetaborgRuntimeException {
        final int size = Iterables2.size(languages);
        this.languages = languages;
        this.buildOrder = new ArrayList<>(size);
        if(size == 0) {
            return;
        }

        // We're only interested in dependencies between given languages, create a lookup map for them.
        final Map<String, ILanguageImpl> lookup = new HashMap<>();
        for(ILanguageImpl language : languages) {
            lookup.put(language.belongsTo().name(), language);
        }

        // Create dependency graph between language implementations.
        final BiSetMultimap<ILanguageImpl, ILanguageImpl> generatedFrom = BiLinkedHashMultimap.create();
        for(ILanguageImpl source : languages) {
            final ILanguageImplConfig config = source.config();
            for(IGenerateConfig generate : config.generates()) {
                final ILanguageImpl target = lookup.get(generate.languageName());
                if(target != null) {
                    generatedFrom.put(target, source);
                }
            }
        }
        
        // Create set of language implementations that are not generated by any other language implementation.
        final Set<ILanguageImpl> diff = Sets.difference(Iterables2.toHashSet(languages), generatedFrom.keySet());
        final Set<ILanguageImpl> notGenerated = new HashSet<>(diff); // Copy set to support removal operations later.
        if(notGenerated.isEmpty()) {
            throw new MetaborgRuntimeException("Build order is cyclic");
        }

        // Execute Kahn's topological sort algorithm to create a build order and check for cycles.
        while(!notGenerated.isEmpty()) {
            final ILanguageImpl impl = notGenerated.iterator().next();
            notGenerated.remove(impl);
            buildOrder.add(impl);

            // Copy collection to prevent ConcurrentModificationException by removal during iteration.
            final Iterable<ILanguageImpl> allGenerates = new ArrayList<>(generatedFrom.getInverse(impl));
            for(ILanguageImpl generates : allGenerates) {
                generatedFrom.remove(generates, impl);
                if(!generatedFrom.containsKey(generates)) {
                    notGenerated.add(generates);
                }
            }
        }
        if(!generatedFrom.isEmpty()) {
            throw new MetaborgRuntimeException("Build order is cyclic");
        }
    }

    /**
     * @return Build order.
     */
    public Iterable<ILanguageImpl> buildOrder() {
        return buildOrder;
    }

    /**
     * @return Languages in this build order, in the same order that they were passed in the constructor.
     */
    public Iterable<ILanguageImpl> languages() {
        return languages;
    }
}
